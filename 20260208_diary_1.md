### 2026/2/8 learning Diary


---
---

這頁在說的是：**UVM 幫你提供一套「把 class 內容打包成 bit/byte/int 陣列，或從這些陣列還原回 class」的機制**，叫做 pack / unpack；實作方式有兩種：用 automation macros，或自己 override `do_pack/do_unpack`。

我分成幾塊配合程式碼講。



## 1. 為什麼要 pack/unpack？

當你有一個 transaction class（例如 `Packet`，裡面有 addr / data / wr），有時需要把它變成一串 bits：

- 要送到某種序列介面（SPI/I2C/RS232 等）。  
- 要寫進 file 或 transaction DB。  
- 要做 pseudo–backdoor injection 或某種壓縮儲存。

UVM 在 `uvm_object` 裡提供一組標準介面：

- `pack / pack_bytes / pack_ints`：把物件欄位串成 bit[] / byte[] / int[]。  
- `unpack / unpack_bytes / unpack_ints`：從這些陣列還原欄位值。



## 2. 用 automation macros 的做法（`uvm_field_int`）

### 2.1 定義 Packet class

```systemverilog
class Packet extends uvm_object;
  rand bit [3:0] m_addr;
  rand bit [3:0] m_wdata;
  rand bit [3:0] m_rdata;
  rand bit       m_wr;

  `uvm_object_utils_begin(Packet)
    `uvm_field_int(m_addr,  UVM_DEFAULT)
    `uvm_field_int(m_wdata, UVM_DEFAULT)
    `uvm_field_int(m_rdata, UVM_DEFAULT)
    `uvm_field_int(m_wr,    UVM_DEFAULT)
  `uvm_object_utils_end

  function new(string name = "Packet");
    super.new(name);
  endfunction
endclass
```

這裡發生的事：

- `Packet` 繼承 `uvm_object`，所以有 pack/unpack 介面。  
- 四個欄位都是 `rand bit`，分別存 addr / write data / read data / write enable。  
- `\`uvm_object_utils_begin/end` + `\`uvm_field_int`：  
  - 幫你把這些欄位註冊進「自動化系統」，  
  - UVM 會自動產生 `do_pack/do_unpack/do_print/do_copy` 等預設實作。  
- 注意：**欄位列出的順序就是 pack/unpack 的順序**；之後還原時也會依這個順序讀回。

### 2.2 pack_test：示範 pack

```systemverilog
class pack_test extends uvm_test;
  `uvm_component_utils(pack_test)

  bit           m_bits[];
  byte unsigned m_bytes[];
  int  unsigned m_ints[];

  virtual function void build_phase(uvm_phase phase);
    Packet m_pkt = Packet::type_id::create("Packet");
    m_pkt.randomize();
    m_pkt.print();

    m_pkt.pack      (m_bits);
    m_pkt.pack_bytes(m_bytes);
    m_pkt.pack_ints (m_ints);

    `uvm_info(get_type_name(), $sformatf("m_bits=%p",  m_bits),  UVM_LOW)
    `uvm_info(get_type_name(), $sformatf("m_bytes=%p", m_bytes), UVM_LOW)
    `uvm_info(get_type_name(), $sformatf("m_ints=%p",  m_ints),  UVM_LOW)
  endfunction
endclass
```

流程：

1. `Packet::type_id::create` new 一個 `m_pkt`，隨機化並 `print` 出欄位值。  
2. `pack(m_bits)`：把四個欄位 bit-wise 串成一個 `bit[]`；長度 = 各欄位 bit 數總和。  
3. `pack_bytes(m_bytes)`：同樣資料，但打包到 `byte[]`。  
   - 因為 `m_wr` 只有 1 bit，湊成 8 bits 時會被補 0。  
4. `pack_ints(m_ints)`：打包成 `int[]`，適合一次放很多 bit。  
5. 用 `uvm_info` 印出三種陣列的內容，所以你可以看到同一筆 Packet 變成三種不同型態的串列。


## 3. unpack_test：把陣列還原回另一個 Packet

```systemverilog
class unpack_test extends uvm_test;
  `uvm_component_utils(unpack_test)

  bit           m_bits[];
  byte unsigned m_bytes[];
  int  unsigned m_ints[];

  int m_val1, m_val2, m_val3;

  virtual function void build_phase(uvm_phase phase);
    Packet m_pkt  = Packet::type_id::create("Packet");
    Packet m_pkt2 = Packet::type_id::create("Packet");
    ...
  endfunction
endclass
```

重點流程分成兩段：

### 3.1 先準備打包好的陣列

- 把 `m_pkt` 多次 randomize + `print` + `pack/pack_bytes/pack_ints`，分別得到三組不同的 `m_bits/m_bytes/m_ints`。  
- 每次 `print` 可以對照：這一組欄位值被打包後，對應到的 bit/byte/int 陣列長什麼樣子。

### 3.2 再用 `m_pkt2` 做還原

```systemverilog
m_val1 = m_pkt2.unpack(m_bits);
m_pkt2.print();

m_val2 = m_pkt2.unpack_bytes(m_bytes);
m_pkt2.print();

m_val3 = m_pkt2.unpack_ints(m_ints);
m_pkt2.print();
```

- `unpack(m_bits)`：按「既定順序」從 `m_bits` 中取出 bit，依次填回 `m_addr/m_wdata/m_rdata/m_wr`。  
- 還原後 `m_pkt2.print()`，你會看到它的欄位值跟當初打包那次 `m_pkt.print()` 一樣。  
- 同理 `unpack_bytes / unpack_ints`。  
- `m_val1/m_val2/m_val3` 是 pack/unpack 回傳的 bit 數，可用來檢查長度是否符合預期。

關鍵提醒：**pack 的順序要跟 unpack 的順序一致**，這也是為什麼用 automation macros 時會說「照 `uvm_object_utils_*` 列出的順序」。


## 4. 不用 automation macros，手動寫 `do_pack/do_unpack`

後面那個 `Packet` 版本改成自己 override：

```systemverilog
class Packet extends uvm_object;
  rand bit [3:0] m_addr;
  rand bit [3:0] m_wdata;
  rand bit [3:0] m_rdata;
  rand bit       m_wr;

  `uvm_object_utils(Packet)

  virtual function void do_print(uvm_printer printer);
    super.do_print(printer);
    printer.print_field_int("m_addr",  m_addr,  $bits(m_addr),  UVM_HEX);
    ...
  endfunction

  virtual function void do_pack(uvm_packer packer);
    super.do_pack(packer);
    packer.pack_field_int(m_addr,  $bits(m_addr));
    packer.pack_field_int(m_wdata, $bits(m_wdata));
    packer.pack_field_int(m_rdata, $bits(m_rdata));
    packer.pack_field_int(m_wr,    $bits(m_wr));
  endfunction

  virtual function void do_unpack(uvm_packer packer);
    super.do_pack(packer);
    m_addr  = packer.unpack_field_int($bits(m_addr));
    m_wdata = packer.unpack_field_int($bits(m_wdata));
    m_rdata = packer.unpack_field_int($bits(m_rdata));
    m_wr    = packer.unpack_field_int($bits(m_wr));
  endfunction
endclass
```

這版本重點：

- 不用 `uvm_field_int` automation，改成自己控制 pack 順序與方式。  
- `do_pack` 會被 `pack/pack_bytes/pack_ints` 呼叫，你在裡面用 `packer.pack_field_int` 決定怎麼推 bit。  
- `do_unpack` 被 `unpack/...` 呼叫，對應 `unpack_field_int` 把 bit 拉回來。  
- 優點：更可控、更清楚可以 debug；缺點：code 比較長。

書上也提示：「automation macros 引進很多額外 code，在大型專案裡一般不建議用太重」，所以實務上很多團隊會傾向用 `do_*` 的寫法。


---
---


先抓重點：`unpack` 就是在「拿之前 pack 好的陣列，還原成另一個 Packet 物件的欄位」，log 只是把還原前後的值印給你看。

下面配著 log 看流程。



## 1) 先有一個「來源 Packet」和三種 packed 陣列

在 `build_phase` 裡他做了這幾件事（簡化）：

```systemverilog
Packet m_pkt  = Packet::type_id::create("Packet");
Packet m_pkt2 = Packet::type_id::create("Packet");  // 之後拿來裝解包結果

// 1) 隨機 m_pkt，pack 到 m_bits
m_pkt.randomize();
m_pkt.print();     // 你看到第一個 Packet print 區塊
m_pkt.pack(m_bits);

// 2) 再隨機一次，pack 到 m_bytes
m_pkt.randomize();
m_pkt.print();     // 第二個 Packet print 區塊
m_pkt.pack_bytes(m_bytes);

// 3) 再隨機一次，pack 到 m_ints
m_pkt.randomize();
m_pkt.print();     // 第三個 Packet print 區塊
m_pkt.pack_ints(m_ints);
```

所以：

- 第一個 `print` 對應到 `m_bits`。  
- 第二個 `print` 對應到 `m_bytes`。  
- 第三個 `print` 對應到 `m_ints`。  

你在 log 前半段看到的三個 Packet 块就是這三次 randomize 之後的值。



## 2) unpack(m_bits)：還原第 1 組資料

```systemverilog
m_val1 = m_pkt2.unpack(m_bits);
m_pkt2.print();
```

- 一開始 `m_pkt2` 是空的（所有欄位是預設值）。  
- `unpack(m_bits)` 會按 pack 時的順序，從 `m_bits` 裡依序取 bit，填進 `m_addr / m_wdata / m_rdata / m_wr`。  
- `m_val1` 是回傳值，代表解了多少 bit（這裡是 0xd = 13，因為 4+4+4+1 = 13 bit）。  
- 接著 `m_pkt2.print()` 把還原後的內容印出來。

對照 log：

```text
UVM_INFO ... Start unpack
UVM_INFO ... unpacked m_val1=0xd
--------------------------------
Name       Type   Size  Value
--------------------------------
Packet ...
  m_addr   ... 4 'hd
  m_wdata  ... 4 'h9
  m_rdata  ... 4 'h6
  m_wr     ... 1 'h1
--------------------------------
```

你會發現這個 Packet 的內容，**跟一開始 pack 到 m_bits 時那個 Packet 的欄位完全一樣**（`d,9,6,1`），代表 unpack 成功把 bit[] 還原回原本的欄位值。



## 3) unpack_bytes(m_bytes)：覆蓋成第 2 組資料

接著：

```systemverilog
m_val2 = m_pkt2.unpack_bytes(m_bytes);
m_pkt2.print();
```

- 這次用的是 `m_bytes`（第二次 randomize 後 pack 出來的 byte[]）。  
- `unpack_bytes` 會覆蓋掉 `m_pkt2` 目前的欄位，換成第二組資料。  

對照 log：

```text
UVM_INFO ... unpacked m_val2=0xd
--------------------------------
Packet ...
  m_addr   'h8
  m_wdata  'he
  m_rdata  'h4
  m_wr     'h0
--------------------------------
```

這一組 (`8,e,4,0`) 正是前面對應 `m_bytes` 那個 Packet print 的內容，表示從 byte[] 成功還原。



## 4) unpack_ints(m_ints)：覆蓋成第 3 組資料

最後：

```systemverilog
m_val3 = m_pkt2.unpack_ints(m_ints);
m_pkt2.print();
```

- 用 `m_ints`（第三組 randomize+pack_ints 的結果）再解一次。  

log：

```text
UVM_INFO ... unpacked m_val3=0xd
--------------------------------
Packet ...
  m_addr   'h9
  m_wdata  'he
  m_rdata  'he
  m_wr     'h1
--------------------------------
```

這組 (`9,e,e,1`) 又對應回 pack_ints 時那個 Packet 的欄位。



## 5) 你可以怎麼理解整段流程

- 把 `Packet` 想成一個 struct：`{addr, wdata, rdata, wr}`。  
- `pack*` 是：  
  「把這個 struct 的欄位照順序攤平成一條 bit/byte/int array」。  
- `unpack*` 是：  
  「拿這條 array，再照同樣順序塞回一個新的 struct 物件」。  

`unpack_test` 這個範例只是用三次 randomize 來展示：  
> 不管你選擇 bits / bytes / ints 當封裝格式，都能完整地把資料「存出去 → 再還原回來」，而且順序和內容都一致。

如果你覺得 pack 理解了，unpack 就是「反向操作」，log 只是在驗證這個反向有沒有做對而已。


---
---


這裡的 `do_` 系列是「給 pack/print/unpack 用的客製化 hook」，換句話說：

- 外面呼叫的是 `pkt.print()`、`pkt.pack()`、`pkt.unpack()`  
- 這三個函式內部會再去呼叫你在 class 裡 override 的 `do_print`、`do_pack`、`do_unpack`，讓你決定怎麼處理每個欄位。

逐段看你貼的 code。



## 1. do_print：客製化 print 內容

```systemverilog
virtual function void do_print(uvm_printer printer);
  super.do_print(printer);
  printer.print_field_int("m_addr",  m_addr,  $bits(m_addr),  UVM_HEX);
  printer.print_field_int("m_wdata", m_wdata, $bits(m_wdata), UVM_HEX);
  printer.print_field_int("m_rdata", m_rdata, $bits(m_rdata), UVM_HEX);
  printer.print_field_int("m_wr",    m_wr,    $bits(m_wr),    UVM_HEX);
endfunction
```

- 當你呼叫 `m_pkt.print()` 時，`uvm_object` 裡的 `print()` 會建立一個 `uvm_printer`，然後呼叫這個 `do_print()`。  
- `super.do_print(printer)`：先讓父類別（`uvm_object`）處理它自己的欄位（如果有）。  
- 後面四行：用 printer 逐個欄位印出：欄位名、值、bit 寬度、十六進位顯示。  
- 所以你在 log 裡看到的那個「Name/Type/Size/Value」表，其實就是 `print()` + `do_print()` 的輸出。



## 2. do_pack：決定「打包順序與內容」

```systemverilog
virtual function void do_pack(uvm_packer packer);
  super.do_pack(packer);
  packer.pack_field_int(m_addr,  $bits(m_addr));
  packer.pack_field_int(m_wdata, $bits(m_wdata));
  packer.pack_field_int(m_rdata, $bits(m_rdata));
  packer.pack_field_int(m_wr,    $bits(m_wr));
endfunction
```

- 當你呼叫 `m_pkt.pack(m_bits)`、`pack_bytes` 或 `pack_ints` 時，這些 API 內部會建立/使用一個 `uvm_packer`，再呼叫 `do_pack(packer)`。  
- `super.do_pack(packer)`：先讓父類別有機會打包它自己的欄位（如果有）。  
- 之後四行，決定 **打包的順序和 bit 數**：  
  1. 先推 `m_addr`（4 bits）  
  2. 再推 `m_wdata`（4 bits）  
  3. 再推 `m_rdata`（4 bits）  
  4. 最後推 `m_wr`（1 bit）  
- 這樣 pack 出來的 bit stream 就是：`{addr[3:0], wdata[3:0], rdata[3:0], wr[0]}` 連在一起，總長度 13 bits。  

之後 `pack()` 會把 `packer` 裡的這串 bits 貼到你傳進去的 `m_bits` / `m_bytes` / `m_ints` 陣列裡。



## 3. do_unpack：照相同順序把 bits 拆回欄位

```systemverilog
virtual function void do_unpack(uvm_packer packer);
  super.do_pack(packer);  // 這裡其實應該是 super.do_unpack(packer)
  m_addr  = packer.unpack_field_int($bits(m_addr));
  m_wdata = packer.unpack_field_int($bits(m_wdata));
  m_rdata = packer.unpack_field_int($bits(m_rdata));
  m_wr    = packer.unpack_field_int($bits(m_wr));
endfunction
```

概念上應該是：

```systemverilog
super.do_unpack(packer);
m_addr  = packer.unpack_field_int(4);
m_wdata = packer.unpack_field_int(4);
m_rdata = packer.unpack_field_int(4);
m_wr    = packer.unpack_field_int(1);
```

- 當你呼叫 `m_pkt2.unpack(m_bits)` / `unpack_bytes` / `unpack_ints` 時，一樣會建立一個 `uvm_packer`，把陣列的資料丟進去，然後呼叫 `do_unpack(packer)`。  
- `unpack_field_int(N)`：從 packer 目前指標位置拿出 N 個 bit，還原成一個整數，然後指標往後移。  
- 因為 `do_unpack` 的順序跟 `do_pack` 一樣，所以：  
  - 先還原出第一個 4 bit → `m_addr`。  
  - 再 4 bit → `m_wdata`。  
  - 再 4 bit → `m_rdata`。  
  - 最後 1 bit → `m_wr`。  
- 這就是為什麼在 unpack 測試裡，你會看到 `m_pkt2` 的欄位值和當初對應那次 `m_pkt` 的欄位值完全一樣。

唯一要注意的是：原文那段 `do_unpack` 裡寫 `super.do_pack(packer);` 應該是 typo，正確應該呼叫 `super.do_unpack(packer);`，意思是「讓父類別也做自己的解包」。



## 總結一句話

- `do_print`：定義「print 時要怎麼把這個 class 的欄位印出來」。  
- `do_pack`：定義「pack 時欄位如何按順序推進 bit stream」。  
- `do_unpack`：定義「unpack 時如何按同樣順序把 bit stream 拆回欄位」。  

外部只需要呼叫 `obj.print()` / `obj.pack()` / `obj.unpack()`，UVM 會自動幫你去調這些 `do_` 函式，讓 class 本身掌握「自己的序列化和顯示方式」。


----
----


這頁是在講 **`uvm_object` 的 compare 功能**，有兩種用法：

1. 用 automation macros，自動幫你產生 compare 邏輯。  
2. 自己 override `do_compare`，完全客製比較規則。

可以把它想成：**給 scoreboard / 單元測試用的一個「深度物件相等判斷」工具**。



## 一、用 automation macros 的 compare

### 1.1 Packet / Object class 做了什麼

```systemverilog
typedef enum {FALSE, TRUE} e_bool;

class Packet extends uvm_object;
  rand bit[15:0] m_addr;

  virtual function string convert2string();
    string contents;
    contents = $sformatf("m_addr=0x%0h", m_addr);
  endfunction

  `uvm_object_utils_begin(Packet)
    `uvm_field_int(m_addr, UVM_DEFAULT)
  `uvm_object_utils_end
endclass
```

- `Packet` 有一個欄位 `m_addr`，用 `uvm_field_int(m_addr, UVM_DEFAULT)` 註冊。  
- 這樣 `Packet.compare()`、`copy()`、`print()` 等都會自動把 `m_addr` 納入處理。

```systemverilog
class Object extends uvm_object;
  rand e_bool m_bool;
  rand bit[3:0] m_mode;
  string m_name;
  rand Packet m_pkt;

  function new(...);
    m_name = name;
    m_pkt = Packet::type_id::create("m_pkt");
    m_pkt.randomize();
  endfunction

  `uvm_object_utils_begin(Object)
    `uvm_field_enum  (e_bool, m_bool, UVM_DEFAULT)
    `uvm_field_int   (m_mode, UVM_DEFAULT)
    `uvm_field_string(m_name, UVM_DEFAULT)
    `uvm_field_object(m_pkt,  UVM_DEFAULT)
  `uvm_object_utils_end
endclass
```

- `Object` 有四個欄位：enum、bit[3:0]、string、一個 `Packet`。  
- 每個欄位用對應的 field Macro註冊，意思是：  
  > compare / copy / print / pack 時，都要把這些欄位算進去，而且 nested object `m_pkt` 也會自動呼叫它自己的 compare。

### 1.2 base_test 裡在做什麼

```systemverilog
Object obj1 = Object::type_id::create("obj1");
Object obj2 = Object::type_id::create("obj2");
obj1.randomize(); obj1.print();
obj2.randomize(); obj2.print();

_compare(obj1, obj2);
```

`_compare` 定義是：

```systemverilog
function void _compare(Object obj1, obj2);
  if (obj2.compare(obj1))
    `uvm_info("TEST", "obj1 and obj2 are same", UVM_LOW)
  else
    `uvm_info("TEST", "obj1 and obj2 are different", UVM_LOW)
endfunction
```

- `obj2.compare(obj1)` 會根據剛剛那些 `uvm_field_*` 自動逐欄位比較：  
  - 先比 `m_bool`，不等就報一條 miscompare。  
  - 再比 `m_mode`。  
  - 再比 `m_name`。  
  - 最後比 `m_pkt`（會調用 `Packet.compare`，再比 `m_addr`）。  

log 裡：

- 一開始 obj1 和 obj2 完全不同，`compare()` 報 miscompare 在 `m_bool`，整體結果「不同」。  
- 然後每次你手動把一個欄位從 obj1 複製到 obj2：  

```systemverilog
obj2.m_bool = obj1.m_bool;   // 再 compare，這次 m_bool 不報錯，但 m_mode 不一樣
obj2.m_mode = obj1.m_mode;   // 再 compare，這次 m_name 不一樣
obj2.m_name = obj1.m_name;   // 再 compare，這次 m_pkt.m_addr 不一樣
obj2.m_pkt.m_addr = obj1.m_pkt.m_addr;  // 再 compare，全都一樣，compare=1
```

每次 compare 你都看到 miscompare 的欄位變少，最後全部一致時 `obj1 and obj2 are same`，這就是自動 compare 的效果。



## 二、用 do_compare 自己寫 compare 規則

第二部分是「不用 `uvm_field_*` automation，改成自己實作 `do_compare`」。

### 2.1 Packet.do_compare

```systemverilog
class Packet extends uvm_object;
  rand bit[15:0] m_addr;

  `uvm_object_utils(Packet)

  virtual function bit do_compare(uvm_object rhs, uvm_comparer comparer);
    bit res;
    Packet _pkt;

    $cast(_pkt, rhs);
    res = super.do_compare(_pkt, comparer) &
          (m_addr == _pkt.m_addr);

    `uvm_info(get_name(), $sformatf("In Packet::do_compare(), res=%0b", res), UVM_LOW)
    return res;
  endfunction
endclass
```

解釋：

- `compare()` 被呼叫時，會去呼叫這個 `do_compare()`。  
- 輸入 `rhs` 是一個 `uvm_object` handle，所以先 `$cast(_pkt, rhs)` 變成 `Packet` 型別。  
- `super.do_compare(...)`：比父類別欄位（通常沒東西，就是 1）。  
- 再 AND 上 `(m_addr == _pkt.m_addr)`。  
- 最後回傳 res = 整體比較結果；並用 `uvm_info` 印 `res`。  

所以 `Packet.compare` 只會比較 `m_addr`，而且你可以在裡面加更多條件、甚至忽略部分欄位。

### 2.2 Object.do_compare

```systemverilog
class Object extends uvm_object;
  rand e_bool m_bool;
  rand bit[3:0] m_mode;
  string m_name;
  rand Packet m_pkt;

  `uvm_object_utils(Object)

  virtual function bit do_compare(uvm_object rhs, uvm_comparer comparer);
    bit res;
    Object _obj;
    $cast(_obj, rhs);

    res = super.do_compare(_obj, comparer) &
          (m_name == _obj.m_name) &
          (m_mode == _obj.m_mode) &
          (m_bool == _obj.m_bool) &
          m_pkt.do_compare(_obj.m_pkt, comparer);

    `uvm_info(get_name(), $sformatf("In Object::do_compare(), res=%0b", res), UVM_LOW)
    return res;
  endfunction
endclass
```

這裡你完全手寫比較邏輯：

- 同樣先 `$cast`。  
- `super.do_compare` 先比父類別。  
- 再用一串 AND 比較 `m_name/m_mode/m_bool`。  
- 最後呼叫 `m_pkt.do_compare(_obj.m_pkt, comparer)` 來比 nested packet。  

這樣的好處：

- 你可以精準控制哪些欄位要比、哪些不要比。  
- 你可以插入自訂 log（現在 log 裡有 `In Packet::do_compare()` 和 `In Object::do_compare()`）。  
- 不依賴 `uvm_field_*` Macro，產生的隱藏 code 比較少，debug 也更直觀。

### 2.3 第二個 base_test 在幹嘛

流程其實跟前面一樣，只是：

- 為了顯示內容，因為沒有 `uvm_field_*` 版的 `print()`，所以他定義 `convert2string()`，在 `uvm_info` 裡印字串。  
- 每次改一個欄位，呼叫 `_compare(obj1, obj2)`，裡面的 `obj2.compare(obj1)` 會觸發你的 `do_compare`，log 裡就看到：  

  - `Packet::do_compare()` 印 `res=0`，`Object::do_compare()` 印 `res=0` → 不同。  
  - 逐步把 m_bool / m_mode / m_name / m_pkt.m_addr 拉齊，最後兩個 `res` 都變 1，物件一致。



## 三、你實際會怎麼用這些東西

1. **scoreboard 比對 expected / actual transaction**  
   你在 scoreboard 裡會有兩個物件：`exp_tx` 和 `act_tx`，直接 `if (!act_tx.compare(exp_tx))`，就可以得到：  
   - 整體是否 match（真/假）。  
   - 哪些欄位 miscompare（UVM comparer 會印 path + lhs/rhs 值）。  

2. **自訂比對規則**  
   比如：  
   - 有些欄位是 don’t-care（例如 timestamp），在 `do_compare` 裡就不 AND 進去。  
   - 或是做範圍比較（例如 latency 允許 +-1 cycle）。  

3. **debug nested object**  
   像這個例子：`Object` 裡有 `m_pkt`，你可以選擇：  
   - 用 `uvm_field_object` 讓 compare 自動遞迴。  
   - 或用 `m_pkt.do_compare(...)` 自己控制呼叫時機與 log 行為。  

對你來說，記住一句話就好：  
> `compare()` 是用來比兩個物件「深度相等」的；不要自己一個一個 `if (a!=b)`，讓 UVM 幫你做 + 印 miscompare log，比較乾淨。  

前半段是「快速用 macros 自動做」，後半段是「進階用 `do_compare` 完全客製」。

---
---

他的程式怪怪的 

```systemverilog

`timescale 1ns/1ns
import uvm_pkg::*;         // 一定要在用 uvm_object / uvm_test 之前
`include "uvm_macros.svh"  // 巨集在這裡

typedef enum {FALSE, TRUE} e_bool;

class Packet extends uvm_object;
  rand bit[15:0] 	m_addr;

  virtual function string convert2string();
    string contents;
    contents = $sformatf("m_addr=0x%0h", m_addr);
  endfunction

  `uvm_object_utils_begin(Packet)
  	`uvm_field_int(m_addr, UVM_DEFAULT)
  `uvm_object_utils_end

  function new(string name = "Packet");
    super.new(name);
  endfunction
endclass

class Object extends uvm_object;
  rand e_bool 				m_bool;
  rand bit[3:0] 			m_mode;
  string 					m_name;
  rand Packet 				m_pkt;

  function new(string name = "Object");
    super.new(name);
    m_name = name;
    m_pkt = Packet::type_id::create("m_pkt");
    m_pkt.randomize();
  endfunction

  `uvm_object_utils_begin(Object)
  	`uvm_field_enum(e_bool, m_bool, UVM_DEFAULT)
  	`uvm_field_int (m_mode, 		UVM_DEFAULT)
  	`uvm_field_string(m_name, 		UVM_DEFAULT)
  	`uvm_field_object(m_pkt, 		UVM_DEFAULT)
  `uvm_object_utils_end
endclass

class base_test extends uvm_test;
  `uvm_component_utils(base_test)
  function new(string name = "base_test", uvm_component parent=null);
    super.new(name, parent);
  endfunction

  function void build_phase(uvm_phase phase);
  	// Create two objects, randomize them and print the contents
    Object obj1 = Object::type_id::create("obj1");
    Object obj2 = Object::type_id::create("obj2");
    obj1.randomize();
    obj1.print();
    obj2.randomize();
    obj2.print();

    _compare(obj1, obj2);

      `uvm_info("TEST", "Copy m_bool", UVM_LOW)
    obj2.m_bool = obj1.m_bool;
    `uvm_info("TEST", $sformatf("Obj2.print: %s", obj2.m_pkt.convert2string()), UVM_LOW) //這裡是我已經改過的部分 原本是obj2.convert2string() 但是我實際去EDA playground 去跑 居然可以跑沒error？！
    _compare(obj1, obj2);

      `uvm_info("TEST", "Copy m_mode", UVM_LOW)
    obj2.m_mode = obj1.m_mode;
    `uvm_info("TEST", $sformatf("Obj2.print: %s", obj2.m_pkt.convert2string()), UVM_LOW)//這裡是我已經改過的部分
    _compare(obj1, obj2);

      `uvm_info("TEST", "Copy m_name", UVM_LOW)
    obj2.m_name = obj1.m_name;
    `uvm_info("TEST", $sformatf("Obj2.print: %s", obj2.m_pkt.convert2string()), UVM_LOW)//這裡是我已經改過的部分
    _compare(obj1, obj2);

      `uvm_info("TEST", "Copy m_pkt.m_addr", UVM_LOW)
    obj2.m_pkt.m_addr = obj1.m_pkt.m_addr;
    `uvm_info("TEST", $sformatf("Obj2.print: %s", obj2.m_pkt.convert2string()), UVM_LOW)//這裡是我已經改過的部分
    _compare(obj1, obj2);
  endfunction

  function void _compare(Object obj1, obj2);
    if (obj2.compare(obj1))
      `uvm_info("TEST", "obj1 and obj2 are same", UVM_LOW)
    else
      `uvm_info("TEST", "obj1 and obj2 are different", UVM_LOW)
  endfunction
endclass

module tb;
	initial begin
		run_test("base_test");
	end
endmodule

```

----
----


這頁在講的是：**`uvm_object` 提供好幾種「把物件內容印出來」的方式：`print`、`do_print`、`sprint`、`convert2string`，以及用 field Macro或自己寫來控制要印哪些欄位、印成什麼格式。** [axolot-logic](https://www.axolot-logic.com/en/tutorials/uvm/2025-05-12-systemverilog_00006/)

我分成四塊配合程式碼講。



## 1. 用 field Macro + `print()`（第一段 example）

這一段的 `Object`：

```systemverilog
class Object extends uvm_object;

  rand e_bool      m_bool;
  rand bit[3:0]    m_mode;
  rand byte        m_data [doulos](https://www.doulos.com/knowhow/systemverilog/uvm/easier-uvm/easier-uvm-coding-guidelines/summary-of-the-easier-uvm-coding-guidelines/);
  rand shortint    m_queue[$];
  string           m_name;

  constraint c_queue { m_queue.size() == 3; }

  function new(string name = "Object");
    super.new(name);
    m_name = name;
  endfunction

  `uvm_object_utils_begin(Object)
    `uvm_field_enum (e_bool,   m_bool,  UVM_DEFAULT)
    `uvm_field_int  (m_mode,   UVM_DEFAULT)
    `uvm_field_sarray_int(m_data,  UVM_DEFAULT)
    `uvm_field_queue_int (m_queue, UVM_DEFAULT)
    `uvm_field_string    (m_name,  UVM_DEFAULT)
  `uvm_object_utils_end
endclass
```

- `extends uvm_object`：拿到 `print/copy/compare/pack` 這些功能的骨架。 [verificationacademy](https://verificationacademy.com/verification-methodology-reference/uvm/docs_1.1c/html/files/base/uvm_object-svh.html)
- `uvm_field_*` 就是你剛問的「field Macro註冊」：  
  告訴 UVM「這些欄位在 print/copy/compare/pack 時都要自動處理」。 [systemverilog](https://www.systemverilog.io/verification/uvm-field-macros/)

`base_test.build_phase()` 裡：

```systemverilog
Object obj = Object::type_id::create("obj");
obj.randomize();
obj.print();
```

- `randomize()`：把所有 rand 欄位隨機化。  
- `print()`：會用預設的 `uvm_printer`，按照剛剛註冊的欄位，印出那張 table。  

你看到的輸出：

- 最上面一行 `obj Object`，底下列出 `m_bool / m_mode / m_data[...] / m_queue[...] / m_name`，都有 type、size、value。  
- 這整個表格是 `uvm_object` 的 `print()` + field Macro自動生成的。 [systemverilog](https://www.systemverilog.io/verification/uvm-field-macros/)



## 2. 用 `do_print()` 取代 field Macro（自訂要印什麼）

第二段他改寫了 `Object`：

```systemverilog
class Object extends uvm_object;

  rand e_bool    m_bool;
  rand bit[3:0]  m_mode;
  rand byte      m_data [doulos](https://www.doulos.com/knowhow/systemverilog/uvm/easier-uvm/easier-uvm-coding-guidelines/summary-of-the-easier-uvm-coding-guidelines/);
  rand shortint  m_queue[$];
  string         m_name;

  constraint c_queue { m_queue.size() == 3; }

  function new(...); ... endfunction

  `uvm_object_utils(Object)  // 注意：不再用 uvm_field_* begin/end

  virtual function void do_print(uvm_printer printer);
    super.do_print(printer);
    printer.print_string("m_bool", m_bool.name());
    printer.print_field_int("m_mode", m_mode, $bits(m_mode), UVM_HEX);
    printer.print_string("m_name", m_name);
  endfunction
endclass
```

重點：

- 不用 `uvm_field_*`，所以 UVM 不會自動知道哪些欄位要印。  
- 改成 override `do_print()`：  
  - `print()` 本身會呼叫 `do_print()`。  
  - 你在 `do_print` 裡，自己決定要印哪些欄位、怎麼印。  

輸出只剩三個欄位：

```text
m_bool  string  TRUE
m_mode  integral 'hd
m_name  string  obj
```

因為你只在 `do_print()` 裡呼叫了這三行，`m_data`、`m_queue` 沒印就完全不出現。 [systemverilog](https://www.systemverilog.io/verification/uvm-field-macros/)

這就是「用 hook (`do_print`) 取代 automation macros」，比較輕量可控。



## 3. `sprint()`：跟 `print()` 一樣，但回傳字串

第三段：

```systemverilog
Object obj = Object::type_id::create("obj");
obj.randomize();

// Instead of obj.print():
`uvm_info(get_type_name(), $sformatf("Contents: %s", obj.sprint()), UVM_LOW)
```

- `sprint()` = 「跟 `print()` 同樣格式，但不要直接印到 log，而是把那段 table 當成 string 回傳」。 [axolot-logic](https://www.axolot-logic.com/en/tutorials/uvm/2025-05-12-systemverilog_00006/)
- 你再用 `uvm_info` 包起來，就可以在前面加字串 `"Contents: "`，或加其他文字。  

輸出就是：

```text
Contents:
-------------------------------
Name  Type ...
...
-------------------------------
```

等於是「`print()` 的結果放進一個字串」，方便你塞進 report system 或 log 檔。 [axolot-logic](https://www.axolot-logic.com/en/tutorials/uvm/2025-05-12-systemverilog_00006/)



## 4. `convert2string()`：完全自訂格式的一行 summary

最後一段是重點，跟你前面自己實驗的很像：

```systemverilog
class Object extends uvm_object;

  rand e_bool   m_bool;
  rand bit[3:0] m_mode;
  rand byte     m_data [doulos](https://www.doulos.com/knowhow/systemverilog/uvm/easier-uvm/easier-uvm-coding-guidelines/summary-of-the-easier-uvm-coding-guidelines/);
  rand shortint m_queue[$];
  string        m_name;

  ...

  `uvm_object_utils(Object)

  virtual function string convert2string();
    string contents = "";
    $sformat(contents, "%s m_name=%s",        contents, m_name);
    $sformat(contents, "%s m_bool=%s",        contents, m_bool.name());
    $sformat(contents, "%s m_mode=0x%0h",     contents, m_mode);
    foreach(m_data[i])
      $sformat(contents, "%s m_data[%0d]=0x%0h", contents, i, m_data[i]);
    return contents;
  endfunction
endclass
```

- `convert2string()` 是 `uvm_object` 裡的 virtual method，預設實作也有，但你可以 override。它的用途就是：**「給物件一個自己定義的單行文字摘要」**。 [cnblogs](https://www.cnblogs.com/bob62/p/3871857.html)
- 裡面用 `$sformat` 不斷把欄位 append 到 `contents`，最後 `return contents;`。  

在 `base_test` 裡：

```systemverilog
Object obj = Object::type_id::create("obj");
obj.randomize();
`uvm_info(get_type_name(),
          $sformatf("convert2string: %s", obj.convert2string()),
          UVM_LOW)
```

- 呼叫 `obj.convert2string()` 拿到那一長串 `"m_name=... m_bool=... m_mode=... m_data[0]=... ..."`.  
- 再用 `uvm_info` 印出來。  

輸出變成一行：

```text
convert2string:
 m_name=obj m_bool=TRUE m_mode=0xe m_data[0]=0xf4 m_data [verificationacademy](https://verificationacademy.com/forums/t/sprint-vs-convert2string/35438)=0xe ...
```

跟 `print()` 的表格不一樣，這完全是你自己 decide 的格式。 [axolot-logic](https://www.axolot-logic.com/en/tutorials/uvm/2025-05-12-systemverilog_00006/)



## 5. 三種方式什麼時候用？

- `print()` + field Macro  
  - 想快速看所有欄位（含 array），不 care 格式，直接一張表。  
  - 適合臨時 debug、小 class。  

- `do_print()`  
  - 只想印部分欄位，或想把某些欄位轉成特定文字。  
  - 適合大型專案，不想用太重的 automation macros。  

- `sprint()`  
  - 想要表格格式，但要當 string 用（塞進 `uvm_info` 或 log）。  

- `convert2string()`  
  - 想要 *自己設計的 summary 格式*（例如 scoreboard、trace、報告）。  
  - 常見 pattern：  
    ```systemverilog
    function string convert2string();
      return $sformatf("addr=%0h data=%0h write=%0b", addr, data, write);
    endfunction
    ```

你剛剛測試的 `obj2.convert2string()`，就是在用這個 hook：  
- `uvm_object` 本來就有一個空的預設版本。  
- `Packet` override 自己的版本。  
- `Object` 如果你也 override，就能做出「一行列出所有欄位」的 summary，跟這頁最後一個例子是一樣的概念。

----
----


這頁在講 `uvm_object` 的「複製功能」：`copy()`、`do_copy()`、`clone()`，跟之前的 `print/do_print/convert2string` 是同一個套路，只是換成「複製欄位」而不是「印欄位」。

我用你貼的三段程式分別說。

***

## 1. 用 field Macro自動實作 `copy()`（第一段）

### 1.1 類別定義在做什麼

```systemverilog
typedef enum {FALSE, TRUE} e_bool;

class Packet extends uvm_object;
  rand bit[15:0] m_addr;

  `uvm_object_utils_begin(Packet)
    `uvm_field_int(m_addr, UVM_DEFAULT)
  `uvm_object_utils_end
endclass
```

- `uvm_field_int(m_addr, UVM_DEFAULT)`：把 `m_addr` 註冊給 UVM，表示這個欄位要被自動的 `copy/print/compare/pack` 等方法處理。  
- 所以 `pkt.copy(other_pkt)` 時，UVM 會自動幫你 `this.m_addr = other_pkt.m_addr;`。

```systemverilog
class Object extends uvm_object;
  rand e_bool     m_bool;
  rand bit[3:0]   m_mode;
  rand byte       m_data [edaplayground](https://www.edaplayground.com/x/8_Ut);
  rand shortint   m_queue[$];
  string          m_name;
  rand Packet     m_pkt;

  constraint c_queue { m_queue.size() == 3; }

  function new(...);
    m_name = name;
    m_pkt  = Packet::type_id::create("m_pkt");
    m_pkt.randomize();
  endfunction

  `uvm_object_utils_begin(Object)
    `uvm_field_enum      (e_bool, m_bool,  UVM_DEFAULT)
    `uvm_field_int       (m_mode,          UVM_DEFAULT)
    `uvm_field_sarray_int(m_data,          UVM_DEFAULT)
    `uvm_field_queue_int (m_queue,         UVM_DEFAULT)
    `uvm_field_string    (m_name,          UVM_DEFAULT)
    `uvm_field_object    (m_pkt,           UVM_DEFAULT)
  `uvm_object_utils_end
endclass
```

- 所有欄位都用對應的 `uvm_field_*` 註冊。  
- 特別是 `m_field_object(m_pkt, UVM_DEFAULT)` → 告訴 UVM：「這是 nested uvm_object，copy 時也要呼叫它自己的 copy。」  

### 1.2 base_test 的流程

```systemverilog
Object obj1 = Object::type_id::create("obj1");
Object obj2 = Object::type_id::create("obj2");
obj1.randomize(); obj1.print();
obj2.randomize(); obj2.print();

obj2.copy(obj1);
`uvm_info("TEST", "After copy", UVM_LOW)
obj2.print();
```

- 一開始 `obj1` 和 `obj2` 各自 randomize，欄位都不同。  
- 呼叫 `obj2.copy(obj1)` 之後：  
  - `m_bool/m_mode/m_data/m_queue/m_name` 全部從 `obj1` 複製到 `obj2`。  
  - `m_pkt` 也會被呼叫它自己的 `copy()`，所以 `obj2.m_pkt.m_addr` = `obj1.m_pkt.m_addr`。  
- `After copy` 那張第三個 table 就是 copy 之後的 `obj2`，你可以看到它的內容完全跟 `obj1` 相同。

這就是「最懶」的用法：**只要用 field Macro註冊欄位，`copy()` 就可以直接用，不用自己寫**。

***

## 2. 自己寫 `do_copy()`（第二段）

這一段是不用 field Macro，改成 override `do_copy()` 來控制複製邏輯。

### 2.1 Packet.do_copy

```systemverilog
class Packet extends uvm_object;
  rand bit[15:0] m_addr;

  virtual function string convert2string();
    string contents;
    contents = $sformatf("m_addr=0x%0h", m_addr);
  endfunction

  `uvm_object_utils(Packet)

  virtual function void do_copy(uvm_object rhs);
    Packet _pkt;
    super.do_copy(rhs);        // 讓父類有機會處理（通常沒東西）
    $cast(_pkt, rhs);          // 將基底 handle 轉回 Packet
    m_addr = _pkt.m_addr;      // 真正的複製動作
    `uvm_info(get_name(), "In Packet::do_copy()", UVM_LOW)
  endfunction
endclass
```

重點：

- `copy()` 是 `uvm_object` 提供的 public 方法，它會呼叫 `do_copy(rhs)`。  
- 你 override `do_copy`，自己決定怎麼把 `rhs` 裡的值搬到 `this`。  
- `rhs` 型別是 `uvm_object`，所以要 `$cast(_pkt, rhs)` 才能用 `m_addr`。  
- `m_addr = _pkt.m_addr;` 就是這個 class 真正的「複製規則」。  

### 2.2 Object.do_copy

```systemverilog
class Object extends uvm_object;
  rand e_bool    m_bool;
  rand bit[3:0]  m_mode;
  rand byte      m_data [edaplayground](https://www.edaplayground.com/x/8_Ut);
  rand shortint  m_queue[$];
  string         m_name;
  rand Packet    m_pkt;
  ...

  virtual function string convert2string();
    string contents = "";
    $sformat(contents, "%s m_name=%s", contents, m_name);
    $sformat(contents, "%s m_bool=%s", contents, m_bool.name());
    $sformat(contents, "%s m_mode=0x%0h", contents, m_mode);
    foreach(m_data[i])
      $sformat(contents, "%s m_data[%0d]=0x%0h", contents, i, m_data[i]);
    return contents;
  endfunction

  `uvm_object_utils(Object)

  virtual function void do_copy(uvm_object rhs);
    Object _obj;
    super.do_copy(rhs);
    $cast(_obj, rhs);
    m_bool  = _obj.m_bool;
    m_mode  = _obj.m_mode;
    m_data  = _obj.m_data;
    m_queue = _obj.m_queue;
    m_name  = _obj.m_name;
    m_pkt.copy(_obj.m_pkt);   // nested object 交給它自己的 copy
    `uvm_info(get_name(), "In Object::do_copy()", UVM_LOW)
  endfunction
endclass
```

- 同樣先 `$cast(_obj, rhs)`，再一個欄位一個欄位 assign。  
- `m_pkt.copy(_obj.m_pkt);`：這裡會觸發前面 `Packet::do_copy()`，所以 nested 物件也被正確複製。  

### 2.3 base_test 裡怎麼用

```systemverilog
Object obj1 = Object::type_id::create("obj1");
Object obj2 = Object::type_id::create("obj2");
obj1.randomize();
`uvm_info("TEST", $sformatf("Obj1.print: %s", obj1.convert2string()), UVM_LOW)
obj2.randomize();
`uvm_info("TEST", $sformatf("Obj2.print: %s", obj2.convert2string()), UVM_LOW)

obj2.copy(obj1);
`uvm_info("TEST", "After copy", UVM_LOW)
`uvm_info("TEST", $sformatf("Obj2.print: %s", obj2.convert2string()), UVM_LOW)
```

- 一開始 `obj1/obj2` 各自隨機，`convert2string()` 看到的是兩組不同的內容。  
- 呼叫 `obj2.copy(obj1)` 時：  
  - 會先跑 `Object::do_copy`，印 `In Object::do_copy()`。  
  - 再跑 `Packet::do_copy`，印 `In Packet::do_copy()`。  
- 最後 `Obj2.print:` 那行顯示 `obj2` 的欄位內容已經和 `obj1` 完全一樣。

這個版本完全不靠 `uvm_field_*`，優點是：**你精準掌控複製邏輯（可以忽略某些欄位、做深拷貝/淺拷貝選擇）**。

***

## 3. `clone()`：幫你 new + copy 一次做完（第三段）

最後一段只是在說：`clone()` = `new + copy()`，而且會回傳新的物件。

```systemverilog
class base_test extends uvm_test;
  `uvm_component_utils(base_test)

  function void build_phase(uvm_phase phase);
    // 只建立 obj1，obj2 只是 handle
    Object obj2;
    Object obj1 = Object::type_id::create("obj1");
    obj1.randomize();
    `uvm_info("TEST", $sformatf("Obj1.print: %s", obj1.convert2string()), UVM_LOW)

    // 用 clone 建一份一模一樣的
    $cast(obj2, obj1.clone());
    `uvm_info("TEST", "After clone", UVM_LOW)
    `uvm_info("TEST", $sformatf("Obj2.print: %s", obj2.convert2string()), UVM_LOW)
  endfunction
endclass
```

- `obj1.clone()`：  
  - 內部會 new 一個同型別的物件。  
  - 再呼叫 `copy()` 把 `obj1` 的內容複製進去。  
  - 回傳型別是 `uvm_object`，所以要 `$cast(obj2, ...)`。  
- 你不需要自己先 `Object::type_id::create("obj2")`。  
- `clone` 適合你想要「拿現有這個 transaction/object 再產生一份完全一樣的拷貝」的場景。

***

## 4. 你在實務上怎麼用這些東西？

- 在 scoreboard / reference model 裡：  
  - 常見 pattern：`act_tx.copy(exp_tx);` 或 `saved_tx = exp_tx.clone();`  
  - 可以很快把一個 transaction 的內容帶到另一個 buffer 裡。

- 想自己控制複製規則時：  
  - override `do_copy()`：例如不想複製某些 debug-only 欄位、或 nested object 要做深拷貝。  

- 想偷懶時：  
  - 小專案可以用 `uvm_field_*`，只要欄位註冊好，`copy()` 就自動 work。  

整頁其實是在延續你已經看過的 pattern：

- `print()` ⇔ `do_print()`  
- `compare()` ⇔ `do_compare()`  
- `pack()` ⇔ `do_pack()`  
- **`copy()` ⇔ `do_copy()`**  
- 再加上一個方便版：`clone()` = new + copy 一起做。

----
----

呃我看完這四篇的結論是可以很rush的看過去  知道有這個東西就好
等下到後面真的有用到再來看 