### 2026/2/3 learning Diary

> [!CAUTION]
> ### 在整個 SoC 裡 APB3 扮演的角色
> - 一般系統結構會是：CPU/主匯流排（AXI/AHB）→ Bridge（AXI/AHB-to-APB）→ 很多 APB 周邊（Timer/UART/GPIO…）。  
> - Bridge 負責把「高性能匯流排的一筆讀寫」翻成「一筆 APB transfer」，所以從 APB 看出去，你只要當一個很單純的 master/slave，不用管多發器、burst、out-of-order 這些複雜東西。  
> - 因為 APB3 是 non‑pipelined，一次只能處理一筆：一筆沒結束之前，下一筆不會開始，所以狀態機非常簡單，也很好做 formal / simulation 驗證。
> ***
>   ### 三個狀態：IDLE → SETUP → ACCESS
> 你可以直接用 1‑hot 或 enum 來寫一個 3-state FSM：IDLE、SETUP、ACCESS。
> 1. IDLE
>  - 匯流排「閒著」，PSEL=0（沒有 slave 被選到），PENABLE=0。
>  - Master 在這邊「想不想發下一筆？」：
>  - 想發：組好下一筆的 PADDR/PWRITE/PWDATA 之後，把 PSEL 拉高、PENABLE 保持 0，跳到 SETUP。
>  - 不發：維持 PSEL=0、PENABLE=0，停在 IDLE。
> 2. SETUP（準備階段）
>  - PSEL=1，PENABLE=0，這一拍叫做「setup phase」，把這筆 transfer 的所有控制資訊穩定到 bus 上：
>  - 地址：PADDR
>  - 方向：PWRITE（1=寫、0=讀）
>  - 要選哪一個 slave：PSELx（多個 PSEL line 中只有一個為 1）
>  - 若是寫：PWDATA 也在這一拍就準備好
>  - 規則：在整個 SETUP → ACCESS 期間，PADDR / PWRITE / PSEL /（寫的話）PWDATA 都不能亂變，否則就等於在同一筆 transfer 中途換地址或換資料。
>  - 下一個 clock rising edge：Master 把 PENABLE 拉 1，進入 ACCESS。
> 3. ACCESS（實際存取階段）
> - PSEL=1，PENABLE=1，表示「這筆交易正式被啟動，slave 應該根據先前的控制資訊做事」。
> - 這一段可能只要 1 拍，也可能被拉長多拍，完全看 slave 的 PREADY：
> - PREADY=0：slave 還在忙（準備寫入/讀出），這一拍叫 wait state，交易尚未完成，Master 不可以動下一筆，控制訊號維持不變，FSM 留在 ACCESS。
> - PREADY=1：這一拍的 rising edge 會視為「這筆 transfer 完成」，Master 下一拍就會把 PSEL 拉回 0、PENABLE 拉回 0，回到 IDLE。
> - 如果這一拍 PSLVERR=1（且同時 PSEL=1、PENABLE=1、PREADY=1），代表這筆 transfer 失敗，上游 bridge/CPU 會收到 error。
> 換句話說：
> - 「完成點」定義在：某個 clock edge 看到 PSEL=1、PENABLE=1、PREADY=1 的那一拍
> - - 在那個 edge，
> - - - 寫：slave 在這個 edge 把 PWDATA latch 進去。
> - - - 讀：Master 在這個 edge 把 PRDATA latch 回來。
>   ***
>   ### 各訊號在一筆 transfer 中「誰先、誰後」
>   以「單筆、無 wait 的寫」為例，時間軸大致是：
>   - T0（IDLE）：PSEL=0、PENABLE=0，匯流排沒事。
>   - T1（SETUP phase）：
>   - - Master 拉高 PSEL，放上 PADDR / PWRITE=1 / PWDATA。
>   - - PENABLE 仍為 0。
>   - - slave 看到 PSEL 被選到，就開始 decode 地址，準備接收資料。
>   - T2（ACCESS phase）：
>   - - Master 拉高 PENABLE（PSEL 保持 1），PADDR/PWRITE/PWDATA 不可以變。
>   - - PREADY=1（假設無 wait），PSEL=1、PENABLE=1、PREADY=1：
>   - - 在 T2 這個 rising edge，slave 把 PWDATA latch 進 register。
>   - - 同一個 edge 之後，Master 的 FSM 視為「這筆完成」，下一拍會回到 IDLE。
>   - T3（回到 IDLE）：
>   - - Master 把 PSEL、PENABLE 拉回 0，準備下一筆或繼續 idle。
>   如果是「寫 + wait state」，差別只在 ACCESS 多待幾拍：
> - T2：PENABLE=1、PSEL=1，但 slave 覺得還沒準備好，把 PREADY 拉 0 → wait；PWDATA 仍要保持。
> - T3：還是 PREADY=0，繼續 wait。
> - T4：slave 準備好了，把 PREADY 拉 1 → 在 T4 這個 edge，transfer 才真正完成，Slave latch PWDATA，Master 下一拍回 IDLE。
>   讀的情況類似，只是資料方向反過來：
> - SETUP：放 PADDR、PWRITE=0、PSEL。  
> - ACCESS：PENABLE=1，slave 在 Access 期間準備 PRDATA；  
>  - - 某一拍 PREADY=1 時，PRDATA 必須在該 edge 前已經穩定，讓 Master 在那個 edge 把資料讀回去。  
>  - - 如果 PREADY 一直 0，就代表 slave 還在準備資料、還不能給。
> ***
> ### PREADY / PSLVERR 的實務感覺
> - PREADY：  
>  - - 你可以想成 slave 對 master 說：「我忙完了，這筆可以結算」的握手信號。  
>  - - 很多簡單周邊會直接把 PREADY 綁死為 1（不插 wait state），這樣每筆 transfer 都固定兩拍（SETUP 一拍 + ACCESS 一拍）。  
> - PSLVERR：  
>  - - 只在 transfer 結束那拍有效：PSEL=1、PENABLE=1、PREADY=1 時的 PSLVERR 才算數。  
>  - - 典型用途：  
>   - - - 訪問 reserved/未實作地址。  
>   - - - Illegal 配置（例如某個模式不支援寫入）。  

---
---

### 2026/2/4 learning Diary

在github 找到兩個關於APB的code 
https://github.com/Karan-nevage/APB-Protocol-Using-Verilog
https://github.com/maomran/APB-Slave

而且找到用UVM去驗證APB的code ！！！ 
https://github.com/Karan-nevage/APB-Protocol-UVM-Based-Verification


原本想將 https://github.com/Karan-nevage/APB-Protocol-Using-Verilog 的程式改成使用FSM 
但後來覺得沒必要 因為state 轉變並沒有這麼複雜 簡單易懂就行
