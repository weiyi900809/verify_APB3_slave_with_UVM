### 2026/2/4 learning Diary

在github 找到兩個關於APB的code 
https://github.com/Karan-nevage/APB-Protocol-Using-Verilog
https://github.com/maomran/APB-Slave

而且找到用UVM去驗證APB的code ！！！ 
https://github.com/Karan-nevage/APB-Protocol-UVM-Based-Verification


原本想將 https://github.com/Karan-nevage/APB-Protocol-Using-Verilog 的程式改成使用FSM 
但動手改到一半 後來覺得沒必要 因為slave 的state 轉變並沒有這麼複雜 不需要用FSM 簡單易懂就行


![uvm](./img/uvm-tb.gif)
這張 GIF 呈現的是一個典型的 **SystemVerilog/UVM 驗證環境 (Testbench)** 結構圖。它展示了各個組件如何分工合作，來驗證待測設計（DUT）的正確性。
以下是根據圖中組件的功能說明：
* **核心組件與流程**

* **Sequencer (定序器)：**
* 負責管控資料流，將測試案例產生的序列（Sequences）傳送給 Driver。
* 圖中顯示「Data」從 Sequencer 出發，它是驗證激勵源的控制中心。


* **Driver (驅動器)：**
* 接收來自 Sequencer 的高階資料，並將其轉換為符合通訊協定（Protocol）的硬體訊號（如位元層級的切換）。
* 它透過 **Interface (介面)** 將訊號輸入到 **DUT (待測設計)**。


* **DUT (Device Under Test, 待測設計)：**
* 這是你正在設計並需要驗證的數位邏輯模組。


* **Monitor (監測器)：**
* 負責「觀察」Interface 上的訊號。它會將 DUT 輸出的硬體訊號重新打包成高階的資料物件（Transactions），並傳送給 Scoreboard。


* **Scoreboard (計分板)：**
* **驗證的核心節點**。它同時接收來自 Driver 的輸入參考資料與來自 Monitor 的 DUT 實際輸出資料。
* 它會比對「預期結果」與「實際結果」是否一致，以此判斷測試是否通過（Pass/Fail）。


* **運作邏輯總結**
1. **激勵產生：** Sequencer → Driver → 透過 Interface 進入 DUT。
2. **結果監測：** DUT 輸出結果 → 透過 Interface 被 Monitor 擷取。
3. **比對驗證：** Driver 的輸入與 Monitor 的輸出匯聚到 Scoreboard 進行比對。

---
---


* ** 核心功能機制**

除了硬體組件外，UVM 還包含以下關鍵軟體特性來提升驗證效率：

* **Transactions (交易物件)**：用來模型化 DUT 與測試平台之間的通訊，透過擴展 UVM 基礎類別來承載資訊。
* **Phases (模擬階段)**：定義了一套嚴格的執行順序（如 `build`, `connect`, `run` 等），確保所有組件依序建立、初始化並執行。
* **Configuration Database (配置資料庫)**：提供一個中心化的資料庫，讓使用者能靈活儲存或讀取各組件的配置參數。
* **Register Abstraction Layer (RAL, 暫存器抽象層)**：簡化了對硬體暫存器映射（Register Maps）的建立與存取操作。
* **Functional Coverage (功能覆蓋率)**：用於追蹤設計是否已按照計畫完成所有功能的測試。
* **Messaging and Reporting (訊息報告機制)**：統一管理模擬過程中的警告、錯誤及除錯資訊輸出。
